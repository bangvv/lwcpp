<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chi Tiáº¿t OOP trong C++</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background: #f4f4f4;
      color: #333;

    }

    header {
      background: #005b99;
      color: white;
      padding: 20px;
      text-align: center;
    }

    nav {
      background: #003f66;
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 10px 0;
    }

    nav a {
      color: white;
      text-decoration: none;
      font-weight: bold;
    }

    nav a:hover {
      text-decoration: underline;
    }

    main {
      padding: 20px;
      max-width: 960px;
      margin: auto;
      background: white;
    }

    h4 {
      color: #005b99;
    }

    pre {
      background: #eee;
      padding: 10px;
      overflow-x: auto;
    }

    code {
      font-family: Consolas, monospace;
      background: #e0e0e0;
      padding: 2px 4px;
      border-radius: 4px;
    }

    a {
      color: #005b99;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .note {
      font-style: italic;
      color: #555;
    }
  </style>
</head>

<body>
  <header>
    <h1>Há»c C++ tá»« CÆ¡ Báº£n Ä‘áº¿n NÃ¢ng Cao</h1>
    <p>Website tá»± há»c láº­p trÃ¬nh C++ miá»…n phÃ­, thá»±c chiáº¿n, dá»… hiá»ƒu</p>
  </header>

  <nav>
    <a href="cpp-bassic.html">C++ CÆ¡ Báº£n</a>
    <a href="cpp-advance.html">C++ NÃ¢ng Cao</a>
    <a href="#stl">STL</a>
    <a href="#build">Build System</a>
    <a href="#du-an">Dá»± Ãn</a>
  </nav>

  <main>
    <section id="oop">
      <h2>1. OOP: Káº¿ thá»«a, Ä‘a hÃ¬nh, Ä‘Ã³ng gÃ³i, trá»«u tÆ°á»£ng</h2>
      <ul>
        <li><strong>Káº¿ thá»«a (Inheritance)</strong>: Cho phÃ©p class con sá»­ dá»¥ng láº¡i thuá»™c tÃ­nh vÃ  phÆ°Æ¡ng thá»©c cá»§a class
          cha.</li>
        <li><strong>Äa hÃ¬nh (Polymorphism)</strong>: Cho phÃ©p gá»i Ä‘Ãºng hÃ m override dá»±a trÃªn kiá»ƒu runtime thÃ´ng qua con
          trá» hoáº·c tham chiáº¿u.</li>
        <li><strong>ÄÃ³ng gÃ³i (Encapsulation)</strong>: Gom toÃ n bá»™ thuá»™c tÃ­nh vÃ  hÃ nh vi liÃªn quan vÃ o trong 1 class, vÃ 
          che giáº¥u cÃ¡c chi tiáº¿t khÃ´ng cáº§n thiáº¿t báº±ng cÃ¡ch dÃ¹ng access modifier (private/protected/public).</li>
        <li><strong>Trá»«u tÆ°á»£ng (Abstraction)</strong>: TÃ¡ch pháº§n giao diá»‡n ra khá»i pháº§n hiá»‡n thá»±c, giÃºp áº©n cÃ¡c chi tiáº¿t
          phá»©c táº¡p, chá»‰ hiá»ƒn thá»‹ nhá»¯ng gÃ¬ cáº§n thiáº¿t Ä‘á»ƒ sá»­ dá»¥ng.</li>
      </ul>
      <pre><code>class Animal {
public:
    virtual void speak() = 0; // Pure virtual function: interface abstraction
};

class Dog : public Animal {
public:
    void speak() override { std::cout << "Woof"; }
};
    </code></pre>
      <div class="note">
        ğŸ”¸ LÆ°u Ã½: Truyá»n object dáº«n xuáº¥t qua giÃ¡ trá»‹ sáº½ gÃ¢y ra hiá»‡n tÆ°á»£ng <strong>object slicing</strong>. NÃªn dÃ¹ng con
        trá» hoáº·c tham chiáº¿u náº¿u cáº§n Ä‘a hÃ¬nh.
      </div>
    </section>

    <section id="ruleof3">
      <h2>2. Rule of Three / Five / Zero & Constructor Enhancements</h2>
      <p><strong>Rule of Three:</strong> Náº¿u báº¡n viáº¿t constructor sao chÃ©p (copy constructor), báº¡n nÃªn viáº¿t thÃªm
        destructor vÃ  toÃ¡n tá»­ gÃ¡n (copy assignment operator).</p>
      <p><strong>Rule of Five:</strong> Bá»• sung thÃªm move constructor vÃ  move assignment operator vá»›i C++11.</p>
      <p><strong>Rule of Zero:</strong> Sá»­ dá»¥ng smart pointer hoáº·c container Ä‘á»ƒ khÃ´ng cáº§n viáº¿t báº¥t ká»³ hÃ m quáº£n lÃ½ tÃ i
        nguyÃªn nÃ o.</p>
      <pre><code>class Resource {
          int* data;
      public:
          Resource(int v) : data(new int(v)) {}
          ~Resource() { delete data; }
          Resource(const Resource& r) : data(new int(*r.data)) {}
          Resource& operator=(const Resource& r) {
              if (this != &r) {
                  delete data;
                  data = new int(*r.data);
              }
              return *this;
          }
      };
      </code></pre>

      <h4>Constructor Delegation</h4>
      <p>DÃ¹ng má»™t constructor gá»i sang constructor khÃ¡c Ä‘á»ƒ giáº£m láº·p code.</p>
      <pre><code>class MyClass {
    int x, y;
public:
    MyClass(int val) : MyClass(val, 0) {} // gá»i constructor 2 tham sá»‘
    MyClass(int a, int b) : x(a), y(b) {}
};
    </code></pre>
      <div class="note">
        âš ï¸ <strong>LÆ°u Ã½:</strong> TrÃ¡nh táº¡o vÃ²ng láº·p vÃ´ háº¡n báº±ng cÃ¡ch gá»i constructor chÃ­nh nÃ³ hoáº·c láº·p chuá»—i
        constructor
        khÃ´ng káº¿t thÃºc.
      </div>

      <h4>=default vÃ  =delete</h4>
      <ul>
        <li>
          <pre><code>=default</code></pre>: YÃªu cáº§u compiler tá»± sinh hÃ m constructor hoáº·c operator máº·c Ä‘á»‹nh.
        </li>
        <li>
          <pre><code>=delete</code></pre>: Cáº¥m compiler tá»± sinh hoáº·c gá»i má»™t hÃ m.
        </li>
      </ul>
      <pre><code>class Example {
public:
    Example() = default; // constructor máº·c Ä‘á»‹nh
    Example(const Example&) = delete; // khÃ´ng cho phÃ©p copy
    Example& operator=(const Example&) = delete; // khÃ´ng gÃ¡n Ä‘Æ°á»£c
    ~Example() = default; // há»§y máº·c Ä‘á»‹nh
};
    </code></pre>
      <div class="note">
        âœ… <strong>LÆ°u Ã½:</strong> Sá»­ dá»¥ng
        <pre><code>=delete</code></pre> giÃºp ngÄƒn lá»—i láº­p trÃ¬nh khi cá»‘ gáº¯ng copy object khÃ´ng nÃªn
        copy. Sá»­ dá»¥ng
        <pre><code>=default</code></pre> giÃºp Ä‘Æ¡n giáº£n code, nhÆ°ng cÅ©ng nÃªn rÃµ rÃ ng vá» Ã½ Ä‘á»‹nh thiáº¿t káº¿.
      </div>
    </section>

    <section id="inheritance">
      <h2>3. Inheritance & Multiple Inheritance: Diamond Problem</h2>
      <p>Khi má»™t class káº¿ thá»«a tá»« nhiá»u class, cÃ³ thá»ƒ gÃ¢y ra xung Ä‘á»™t, Ä‘áº·c biá»‡t khi cÃ¹ng káº¿ thá»«a tá»« má»™t base class â€” gá»i
        lÃ  Diamond Problem.</p>
      <pre><code>class A { public: void hello() {} };
class B : public virtual A {};
class C : public virtual A {};
class D : public B, public C {};
D d; d.hello();
    </code></pre>
      <div class="note">
        ğŸ”¸ <strong>LÆ°u Ã½:</strong> DÃ¹ng tá»« khÃ³a
        <pre><code>virtual</code></pre> khi káº¿ thá»«a Ä‘á»ƒ Ä‘áº£m báº£o chá»‰ tá»“n táº¡i má»™t instance cá»§a A trong D.
      </div>
      <h4>Äa hÃ¬nh tÄ©nh vs Ä‘á»™ng</h4>
      <ul>
        <li><strong>Äa hÃ¬nh tÄ©nh (Compile-time)</strong>: Xáº£y ra khi náº¡p chá»“ng hÃ m (function overloading) hoáº·c náº¡p chá»“ng
          toÃ¡n tá»­ (operator overloading). Quyáº¿t Ä‘á»‹nh táº¡i thá»i Ä‘iá»ƒm biÃªn dá»‹ch.</li>
        <li><strong>Äa hÃ¬nh Ä‘á»™ng (Runtime)</strong>: Xáº£y ra khi sá»­ dá»¥ng con trá» hoáº·c tham chiáº¿u Ä‘áº¿n lá»›p cÆ¡ sá»Ÿ vÃ 
          override virtual function á»Ÿ lá»›p con. Quyáº¿t Ä‘á»‹nh táº¡i runtime thÃ´ng qua cÆ¡ cháº¿ vtable.</li>
      </ul>
      <pre><code>// Compile-time polymorphism
int add(int a, int b);      // overloading
float add(float a, float b);

// Runtime polymorphism
class Base { public: virtual void show() { std::cout << "Base"; } };
class Derived : public Base { public: void show() override { std::cout << "Derived"; } };
Base* b = new Derived();
b->show();  // prints "Derived"
    </code></pre>
      <div class="note">
        ğŸ”¸ Äa hÃ¬nh tÄ©nh cho hiá»‡u suáº¥t cao hÆ¡n nhÆ°ng kÃ©m linh hoáº¡t hÆ¡n. Äa hÃ¬nh Ä‘á»™ng linh hoáº¡t nhÆ°ng cÃ³ chi phÃ­ hiá»‡u nÄƒng
        vÃ  cáº§n quáº£n lÃ½ Ä‘Ãºng Ä‘á»ƒ trÃ¡nh lá»—i runtime.
      </div>
    </section>

    <section id="static">
      <h2>4. Static Members & Friend Functions</h2>
      <p><strong>Static member</strong>: DÃ¹ng chung cho má»i object, khÃ´ng phá»¥ thuá»™c instance cá»¥ thá»ƒ. <br> <strong>LÆ°u
          Ã½:</strong> Chá»‰ cÃ³ cÃ¡c
      <pre><code>static function</code></pre> má»›i cÃ³ thá»ƒ truy cáº­p trá»±c tiáº¿p
      <pre><code>static member</code></pre>.</p>
      <pre><code>class Counter {
    static int count; // chá»‰ cÃ³ má»™t biáº¿n duy nháº¥t trong bá»™ nhá»›
public:
    Counter() { ++count; }
    static int getCount() { return count; } // chá»‰ static function gá»i Ä‘Æ°á»£c static member
};
int Counter::count = 0;
    </code></pre>
      <ul>
        <li>Static function khÃ´ng thá»ƒ truy cáº­p non-static member vÃ¬ nÃ³ khÃ´ng cÃ³ Ä‘á»‘i tÆ°á»£ng cá»¥ thá»ƒ (this pointer).</li>
        <li>ThÆ°á»ng dÃ¹ng Ä‘á»ƒ Ä‘áº¿m sá»‘ lÆ°á»£ng instance hoáº·c chia sáº» tráº¡ng thÃ¡i toÃ n cá»¥c giá»¯a cÃ¡c object.</li>
      </ul>
      <p><strong>Friend function / friend class</strong>: Cho phÃ©p truy cáº­p vÃ o thÃ nh pháº§n private/protected cá»§a class
        mÃ  khÃ´ng cáº§n káº¿ thá»«a.</p>
      <pre><code>class Box {
private:
    int value;
    friend void showValue(const Box&);
};
void showValue(const Box& b) {
    std::cout << b.value;
}
    </code></pre>
      <div class="note">
        âš ï¸ LÆ°u Ã½: <strong>Friend</strong> phÃ¡ vá»¡ tÃ­nh Ä‘Ã³ng gÃ³i, chá»‰ nÃªn dÃ¹ng trong cÃ¡c trÆ°á»ng há»£p Ä‘áº·c biá»‡t nhÆ° overload
        operator, unit test, hoáº·c tá»‘i Æ°u performance khi interface public khÃ´ng Ä‘á»§ linh hoáº¡t.
      </div>
    </section>

    <section id="virtual">
      <h2>5. Virtual Destructor & Object Slicing</h2>
      <p><strong>Virtual destructor</strong>: Äáº£m báº£o gá»i Ä‘Ãºng destructor khi xÃ³a object qua con trá» base class.</p>
      <pre><code>class Base {
public:
    virtual ~Base() { std::cout << "Base destructor\n"; }
};
class Derived : public Base {
public:
    ~Derived() { std::cout << "Derived destructor\n"; }
};
Base* obj = new Derived();
delete obj; // gá»i Ä‘Ãºng cáº£ 2 destructor
    </code></pre>
      <p><strong>Object Slicing:</strong> Khi truyá»n object báº±ng giÃ¡ trá»‹, pháº§n dá»¯ liá»‡u riÃªng cá»§a class con sáº½ bá»‹ cáº¯t bá».
      </p>
      <pre><code>class A { 
  public: int x; 
};
class B : public A {
   public: int y; 
};
A a = B(); // slicing: y bá»‹ bá»
    </code></pre>
    </section>

    <section id="patterns">
      <h2>6. Design Patterns (Singleton, Factory, Strategy, Observer)</h2>

      <h4>Singleton</h4>
      <p>Äáº£m báº£o chá»‰ cÃ³ má»™t instance toÃ n cá»¥c duy nháº¥t vÃ  truy cáº­p thá»‘ng nháº¥t.</p>
      <pre><code>class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance; // thread-safe tá»« C++11
        return instance;
    }
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
private:
    Singleton() = default;
};
    </code></pre>
      <div class="note">
        âœ… Æ¯u Ä‘iá»ƒm: Äáº£m báº£o chá»‰ cÃ³ 1 instance, dÃ¹ng chung toÃ n há»‡ thá»‘ng.<br>
        âŒ NhÆ°á»£c Ä‘iá»ƒm: KhÃ³ test unit, dá»… gÃ¢y phá»¥ thuá»™c toÃ n cá»¥c (global dependency).
      </div>

      <h4>Factory</h4>
      <p>áº¨n logic khá»Ÿi táº¡o object, táº¡o object thÃ´ng qua interface thay vÃ¬ new trá»±c tiáº¿p.</p>
      <pre><code>class Product {
public:
    virtual void use() = 0;
    virtual ~Product() = default;
};

class ConcreteProduct : public Product {
public:
    void use() override { std::cout << "Used ConcreteProduct"; }
};

class Factory {
public:
    static Product* createProduct() { return new ConcreteProduct(); }
};
    </code></pre>
      <div class="note">
        âœ… Æ¯u Ä‘iá»ƒm: Dá»… má»Ÿ rá»™ng, giáº£m phá»¥ thuá»™c cá»¥ thá»ƒ.<br>
        âŒ NhÆ°á»£c Ä‘iá»ƒm: TÄƒng sá»‘ lÆ°á»£ng class, khÃ³ debug náº¿u khÃ´ng cÃ³ logging rÃµ rÃ ng.
      </div>

      <h4>Strategy</h4>
      <p>Cho phÃ©p thay Ä‘á»•i thuáº­t toÃ¡n runtime thÃ´ng qua interface.</p>
      <pre><code>class SortStrategy {
public:
    virtual void sort() = 0;
    virtual ~SortStrategy() = default;
};

class QuickSort : public SortStrategy {
public:
    void sort() override { std::cout << "QuickSort applied"; }
};

class SortContext {
private:
    SortStrategy* strategy;
public:
    void setStrategy(SortStrategy* s) { strategy = s; }
    void execute() { strategy->sort(); }
};
    </code></pre>
      <div class="note">
        âœ… Æ¯u Ä‘iá»ƒm: Linh hoáº¡t thay Ä‘á»•i thuáº­t toÃ¡n.<br>
        âŒ NhÆ°á»£c Ä‘iá»ƒm: Pháº£i quáº£n lÃ½ thÃªm cÃ¡c class strategy.
      </div>

      <h4>Observer</h4>
      <p>ThÃ´ng bÃ¡o cho nhiá»u Ä‘á»‘i tÆ°á»£ng khi cÃ³ thay Ä‘á»•i tráº¡ng thÃ¡i.</p>
      <pre><code>class Observer {
public:
    virtual void update(int value) = 0;
};

class Subject {
    std::vector<Observer*> observers;
    int state = 0;
public:
    void attach(Observer* obs) { observers.push_back(obs); }
    void setState(int v) {
        state = v;
        for (auto obs : observers) obs->update(state);
    }
};
    </code></pre>
      <div class="note">
        âœ… Æ¯u Ä‘iá»ƒm: TÃ¡ch biá»‡t Ä‘á»‘i tÆ°á»£ng phÃ¡t sinh thay Ä‘á»•i vÃ  ngÆ°á»i theo dÃµi.<br>
        âŒ NhÆ°á»£c Ä‘iá»ƒm: KhÃ³ debug lá»—i thá»© tá»± hoáº·c vÃ²ng láº·p cáº­p nháº­t.
      </div>
    </section>

    <p><a href="cpp-advance.html">â† Quay láº¡i C++ NÃ¢ng Cao</a></p>
  </main>
</body>

</html>