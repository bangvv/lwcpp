<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chi Ti·∫øt OOP trong C++</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background: #f4f4f4;
      color: #333;

    }

    header {
      background: #005b99;
      color: white;
      padding: 20px;
      text-align: center;
    }

    nav {
      background: #003f66;
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 10px 0;
    }

    nav a {
      color: white;
      text-decoration: none;
      font-weight: bold;
    }

    nav a:hover {
      text-decoration: underline;
    }

    main {
      padding: 20px;
      max-width: 960px;
      margin: auto;
      background: white;
    }

    h4 {
      color: #005b99;
    }

    pre {
      background: #eee;
      padding: 10px;
      overflow-x: auto;
    }

    code {
      font-family: Consolas, monospace;
      background: #e0e0e0;
      padding: 2px 4px;
      border-radius: 4px;
    }

    a {
      color: #005b99;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .note {
      font-style: italic;
      color: #555;
    }
  </style>
</head>

<body>
  <header>
    <h1>H·ªçc C++ t·ª´ C∆° B·∫£n ƒë·∫øn N√¢ng Cao</h1>
    <p>Website t·ª± h·ªçc l·∫≠p tr√¨nh C++ mi·ªÖn ph√≠, th·ª±c chi·∫øn, d·ªÖ hi·ªÉu</p>
  </header>

  <nav>
    <a href="cpp-bassic.html">C++ C∆° B·∫£n</a>
    <a href="cpp-advance.html">C++ N√¢ng Cao</a>
    <a href="#stl">STL</a>
    <a href="#build">Build System</a>
    <a href="#du-an">D·ª± √Ån</a>
  </nav>

  <main>
    <section id="oop">
      <h2>1. OOP: K·∫ø th·ª´a, ƒëa h√¨nh, ƒë√≥ng g√≥i, tr·ª´u t∆∞·ª£ng</h2>
      <ul>
        <li><strong>K·∫ø th·ª´a (Inheritance)</strong>: Cho ph√©p class con s·ª≠ d·ª•ng l·∫°i thu·ªôc t√≠nh v√† ph∆∞∆°ng th·ª©c c·ªßa class
          cha.</li>
        <li><strong>ƒêa h√¨nh (Polymorphism)</strong>: Cho ph√©p g·ªçi ƒë√∫ng h√†m override d·ª±a tr√™n ki·ªÉu runtime th√¥ng qua con
          tr·ªè ho·∫∑c tham chi·∫øu.</li>
        <li><strong>ƒê√≥ng g√≥i (Encapsulation)</strong>: Gom to√†n b·ªô thu·ªôc t√≠nh v√† h√†nh vi li√™n quan v√†o trong 1 class, v√†
          che gi·∫•u c√°c chi ti·∫øt kh√¥ng c·∫ßn thi·∫øt b·∫±ng c√°ch d√πng access modifier (private/protected/public).</li>
        <li><strong>Tr·ª´u t∆∞·ª£ng (Abstraction)</strong>: T√°ch ph·∫ßn giao di·ªán ra kh·ªèi ph·∫ßn hi·ªán th·ª±c, gi√∫p ·∫©n c√°c chi ti·∫øt
          ph·ª©c t·∫°p, ch·ªâ hi·ªÉn th·ªã nh·ªØng g√¨ c·∫ßn thi·∫øt ƒë·ªÉ s·ª≠ d·ª•ng.</li>
      </ul>
      <pre><code>class Animal {
public:
    virtual void speak() = 0; // Pure virtual function: interface abstraction
};

class Dog : public Animal {
public:
    void speak() override { std::cout << "Woof"; }
};
    </code></pre>
      <div class="note">
        üî∏ L∆∞u √Ω: Truy·ªÅn object d·∫´n xu·∫•t qua gi√° tr·ªã s·∫Ω g√¢y ra hi·ªán t∆∞·ª£ng <strong>object slicing</strong>. N√™n d√πng con
        tr·ªè ho·∫∑c tham chi·∫øu n·∫øu c·∫ßn ƒëa h√¨nh.
      </div>
    </section>

    <section id="ruleof3">
      <h2>2. Rule of Three / Five / Zero & Constructor Enhancements</h2>
      <p><strong>Rule of Three:</strong> N·∫øu b·∫°n vi·∫øt constructor sao ch√©p (copy constructor), b·∫°n n√™n vi·∫øt th√™m
        destructor v√† to√°n t·ª≠ g√°n (copy assignment operator).</p>
      <p><strong>Rule of Five:</strong> B·ªï sung th√™m move constructor v√† move assignment operator v·ªõi C++11.</p>
      <p><strong>Rule of Zero:</strong> S·ª≠ d·ª•ng smart pointer ho·∫∑c container ƒë·ªÉ kh√¥ng c·∫ßn vi·∫øt b·∫•t k·ª≥ h√†m qu·∫£n l√Ω t√†i
        nguy√™n n√†o.</p>
      <pre><code>class Resource {
          int* data;
      public:
          Resource(int v) : data(new int(v)) {}
          ~Resource() { delete data; }
          Resource(const Resource& r) : data(new int(*r.data)) {}
          Resource& operator=(const Resource& r) {
              if (this != &r) {
                  delete data;
                  data = new int(*r.data);
              }
              return *this;
          }
      };
      </code></pre>

      <h4>Constructor Delegation</h4>
      <p>D√πng m·ªôt constructor g·ªçi sang constructor kh√°c ƒë·ªÉ gi·∫£m l·∫∑p code.</p>
      <pre><code>class MyClass {
    int x, y;
public:
    MyClass(int val) : MyClass(val, 0) {} // g·ªçi constructor 2 tham s·ªë
    MyClass(int a, int b) : x(a), y(b) {}
};
    </code></pre>
      <div class="note">
        ‚ö†Ô∏è <strong>L∆∞u √Ω:</strong> Tr√°nh t·∫°o v√≤ng l·∫∑p v√¥ h·∫°n b·∫±ng c√°ch g·ªçi constructor ch√≠nh n√≥ ho·∫∑c l·∫∑p chu·ªói
        constructor
        kh√¥ng k·∫øt th√∫c.
      </div>

      <h4>=default v√† =delete</h4>
      <ul>
        <li>
          <pre><code>=default</code></pre>: Y√™u c·∫ßu compiler t·ª± sinh h√†m constructor ho·∫∑c operator m·∫∑c ƒë·ªãnh.
        </li>
        <li>
          <pre><code>=delete</code></pre>: C·∫•m compiler t·ª± sinh ho·∫∑c g·ªçi m·ªôt h√†m.
        </li>
      </ul>
      <pre><code>class Example {
public:
    Example() = default; // constructor m·∫∑c ƒë·ªãnh
    Example(const Example&) = delete; // kh√¥ng cho ph√©p copy
    Example& operator=(const Example&) = delete; // kh√¥ng g√°n ƒë∆∞·ª£c
    ~Example() = default; // h·ªßy m·∫∑c ƒë·ªãnh
};
    </code></pre>
      <div class="note">
        ‚úÖ <strong>L∆∞u √Ω:</strong> S·ª≠ d·ª•ng
        <pre><code>=delete</code></pre> gi√∫p ngƒÉn l·ªói l·∫≠p tr√¨nh khi c·ªë g·∫Øng copy object kh√¥ng n√™n
        copy. S·ª≠ d·ª•ng
        <pre><code>=default</code></pre> gi√∫p ƒë∆°n gi·∫£n code, nh∆∞ng c≈©ng n√™n r√µ r√†ng v·ªÅ √Ω ƒë·ªãnh thi·∫øt k·∫ø.
      </div>
    </section>

    <section id="inheritance">
      <h2>3. Inheritance & Multiple Inheritance: Diamond Problem</h2>
      <p>Khi m·ªôt class k·∫ø th·ª´a t·ª´ nhi·ªÅu class, c√≥ th·ªÉ g√¢y ra xung ƒë·ªôt, ƒë·∫∑c bi·ªát khi c√πng k·∫ø th·ª´a t·ª´ m·ªôt base class ‚Äî g·ªçi
        l√† Diamond Problem.</p>
      <pre><code>class A { public: void hello() {} };
class B : public virtual A {};
class C : public virtual A {};
class D : public B, public C {};
D d; d.hello();
    </code></pre>
      <div class="note">
        üî∏ <strong>L∆∞u √Ω:</strong> D√πng t·ª´ kh√≥a
        <pre><code>virtual</code></pre> khi k·∫ø th·ª´a ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ t·ªìn t·∫°i m·ªôt instance c·ªßa A trong D.
      </div>
      <h4>ƒêa h√¨nh tƒ©nh vs ƒë·ªông</h4>
      <ul>
        <li><strong>ƒêa h√¨nh tƒ©nh (Compile-time)</strong>: X·∫£y ra khi n·∫°p ch·ªìng h√†m (function overloading) ho·∫∑c n·∫°p ch·ªìng
          to√°n t·ª≠ (operator overloading). Quy·∫øt ƒë·ªãnh t·∫°i th·ªùi ƒëi·ªÉm bi√™n d·ªãch.</li>
        <li><strong>ƒêa h√¨nh ƒë·ªông (Runtime)</strong>: X·∫£y ra khi s·ª≠ d·ª•ng con tr·ªè ho·∫∑c tham chi·∫øu ƒë·∫øn l·ªõp c∆° s·ªü v√†
          override virtual function ·ªü l·ªõp con. Quy·∫øt ƒë·ªãnh t·∫°i runtime th√¥ng qua c∆° ch·∫ø vtable.</li>
      </ul>
      <pre><code>// Compile-time polymorphism
int add(int a, int b);      // overloading
float add(float a, float b);

// Runtime polymorphism
class Base { public: virtual void show() { std::cout << "Base"; } };
class Derived : public Base { public: void show() override { std::cout << "Derived"; } };
Base* b = new Derived();
b->show();  // prints "Derived"
    </code></pre>
      <div class="note">
        üî∏ ƒêa h√¨nh tƒ©nh cho hi·ªáu su·∫•t cao h∆°n nh∆∞ng k√©m linh ho·∫°t h∆°n. ƒêa h√¨nh ƒë·ªông linh ho·∫°t nh∆∞ng c√≥ chi ph√≠ hi·ªáu nƒÉng
        v√† c·∫ßn qu·∫£n l√Ω ƒë√∫ng ƒë·ªÉ tr√°nh l·ªói runtime.
      </div>
    </section>

    <section id="static">
      <h2>4. Static Members & Friend Functions</h2>
      <p><strong>Static member</strong>: D√πng chung cho m·ªçi object, kh√¥ng ph·ª• thu·ªôc instance c·ª• th·ªÉ. <br> <strong>L∆∞u
          √Ω:</strong> Ch·ªâ c√≥ c√°c
      <pre><code>static function</code></pre> m·ªõi c√≥ th·ªÉ truy c·∫≠p tr·ª±c ti·∫øp
      <pre><code>static member</code></pre>.</p>
      <pre><code>class Counter {
    static int count; // ch·ªâ c√≥ m·ªôt bi·∫øn duy nh·∫•t trong b·ªô nh·ªõ
public:
    Counter() { ++count; }
    static int getCount() { return count; } // ch·ªâ static function g·ªçi ƒë∆∞·ª£c static member
};
int Counter::count = 0;
    </code></pre>
      <ul>
        <li>Static function kh√¥ng th·ªÉ truy c·∫≠p non-static member v√¨ n√≥ kh√¥ng c√≥ ƒë·ªëi t∆∞·ª£ng c·ª• th·ªÉ (this pointer).</li>
        <li>Th∆∞·ªùng d√πng ƒë·ªÉ ƒë·∫øm s·ªë l∆∞·ª£ng instance ho·∫∑c chia s·∫ª tr·∫°ng th√°i to√†n c·ª•c gi·ªØa c√°c object.</li>
      </ul>
      <p><strong>Friend function / friend class</strong>: Cho ph√©p truy c·∫≠p v√†o th√†nh ph·∫ßn private/protected c·ªßa class
        m√† kh√¥ng c·∫ßn k·∫ø th·ª´a.</p>
      <pre><code>class Box {
private:
    int value;
    friend void showValue(const Box&);
};
void showValue(const Box& b) {
    std::cout << b.value;
}
    </code></pre>
      <div class="note">
        ‚ö†Ô∏è L∆∞u √Ω: <strong>Friend</strong> ph√° v·ª° t√≠nh ƒë√≥ng g√≥i, ch·ªâ n√™n d√πng trong c√°c tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát nh∆∞ overload
        operator, unit test, ho·∫∑c t·ªëi ∆∞u performance khi interface public kh√¥ng ƒë·ªß linh ho·∫°t.
      </div>
    </section>

    <section id="virtual">
      <h2>5. Virtual Destructor & Object Slicing</h2>
      <p><strong>Virtual destructor</strong>: ƒê·∫£m b·∫£o g·ªçi ƒë√∫ng destructor khi x√≥a object qua con tr·ªè base class.</p>
      <pre><code>class Base {
public:
    virtual ~Base() { std::cout << "Base destructor\n"; }
};
class Derived : public Base {
public:
    ~Derived() { std::cout << "Derived destructor\n"; }
};
Base* obj = new Derived();
delete obj; // g·ªçi ƒë√∫ng c·∫£ 2 destructor
    </code></pre>
      <p><strong>Object Slicing:</strong> Khi truy·ªÅn object b·∫±ng gi√° tr·ªã, ph·∫ßn d·ªØ li·ªáu ri√™ng c·ªßa class con s·∫Ω b·ªã c·∫Øt b·ªè.
      </p>
      <pre><code>class A { 
  public: int x; 
};
class B : public A {
   public: int y; 
};
A a = B(); // slicing: y b·ªã b·ªè
    </code></pre>
    </section>

    <section id="patterns">
      <h2>6. Design Patterns (Singleton, Factory, Strategy, Observer)</h2>

      <h4>Singleton</h4>
      <p>ƒê·∫£m b·∫£o ch·ªâ c√≥ m·ªôt instance to√†n c·ª•c duy nh·∫•t v√† truy c·∫≠p th·ªëng nh·∫•t.</p>
      <pre><code>class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance; // thread-safe t·ª´ C++11
        return instance;
    }
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
private:
    Singleton() = default;
};
    </code></pre>
      <div class="note">
        ‚úÖ ∆Øu ƒëi·ªÉm: ƒê·∫£m b·∫£o ch·ªâ c√≥ 1 instance, d√πng chung to√†n h·ªá th·ªëng.<br>
        ‚ùå Nh∆∞·ª£c ƒëi·ªÉm: Kh√≥ test unit, d·ªÖ g√¢y ph·ª• thu·ªôc to√†n c·ª•c (global dependency).
      </div>

      <h4>Factory</h4>
      <p>·∫®n logic kh·ªüi t·∫°o object, t·∫°o object th√¥ng qua interface thay v√¨ new tr·ª±c ti·∫øp.</p>
      <pre><code>class Product {
public:
    virtual void use() = 0;
    virtual ~Product() = default;
};

class ConcreteProduct : public Product {
public:
    void use() override { std::cout << "Used ConcreteProduct"; }
};

class Factory {
public:
    static Product* createProduct() { return new ConcreteProduct(); }
};
    </code></pre>
      <div class="note">
        ‚úÖ ∆Øu ƒëi·ªÉm: D·ªÖ m·ªü r·ªông, gi·∫£m ph·ª• thu·ªôc c·ª• th·ªÉ.<br>
        ‚ùå Nh∆∞·ª£c ƒëi·ªÉm: TƒÉng s·ªë l∆∞·ª£ng class, kh√≥ debug n·∫øu kh√¥ng c√≥ logging r√µ r√†ng.
      </div>

      <h4>Strategy</h4>
      <p>Cho ph√©p thay ƒë·ªïi thu·∫≠t to√°n runtime th√¥ng qua interface.</p>
      <pre><code>class SortStrategy {
public:
    virtual void sort() = 0;
    virtual ~SortStrategy() = default;
};

class QuickSort : public SortStrategy {
public:
    void sort() override { std::cout << "QuickSort applied"; }
};

class SortContext {
private:
    SortStrategy* strategy;
public:
    void setStrategy(SortStrategy* s) { strategy = s; }
    void execute() { strategy->sort(); }
};
    </code></pre>
      <div class="note">
        ‚úÖ ∆Øu ƒëi·ªÉm: Linh ho·∫°t thay ƒë·ªïi thu·∫≠t to√°n.<br>
        ‚ùå Nh∆∞·ª£c ƒëi·ªÉm: Ph·∫£i qu·∫£n l√Ω th√™m c√°c class strategy.
      </div>

      <h4>Observer</h4>
      <p>Th√¥ng b√°o cho nhi·ªÅu ƒë·ªëi t∆∞·ª£ng khi c√≥ thay ƒë·ªïi tr·∫°ng th√°i.</p>
      <pre><code>class Observer {
public:
    virtual void update(int value) = 0;
};

class Subject {
    std::vector<Observer*> observers;
    int state = 0;
public:
    void attach(Observer* obs) { observers.push_back(obs); }
    void setState(int v) {
        state = v;
        for (auto obs : observers) obs->update(state);
    }
};
    </code></pre>
      <div class="note">
        ‚úÖ ∆Øu ƒëi·ªÉm: T√°ch bi·ªát ƒë·ªëi t∆∞·ª£ng ph√°t sinh thay ƒë·ªïi v√† ng∆∞·ªùi theo d√µi.<br>
        ‚ùå Nh∆∞·ª£c ƒëi·ªÉm: Kh√≥ debug l·ªói th·ª© t·ª± ho·∫∑c v√≤ng l·∫∑p c·∫≠p nh·∫≠t.
      </div>
    </section>

    <p><a href="cpp-advance.html">‚Üê Quay l·∫°i C++ N√¢ng Cao</a></p>
  </main>
</body>

</html>